<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAD MATCHUPS - Game</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        /* Styling similar to original */
        body { /* Styles for body */ }
        .game-container { /* Styles for game container */ }
        h1 { /* Styles for title */ }
        #game-status, #turn-status { /* Styles for status text */ }
        #move-log { /* Styles for move log */ }
        #input-area { /* Styles for input area */ }
        #promptInput { /* Styles for prompt input */ }
        button { /* Styles for submit button */ }
        button:hover { /* Hover effect */ }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Gemini Text Generation Game</h1>
        <div id="game-status">Game ID: {{ game_id }}</div>
        <div id="turn-status">Waiting for turn...</div>
        <div id="move-log">This is a move log for user 1 and 2</div>

        <div id="input-area">
            <input type="text" id="promptInput" placeholder="Enter your prompt here">
            <button onclick="submitMove()">Submit</button>
        </div>
    </div>

    <script>
        const gameId = "{{ game_id }}";
        let myTurn = false;

        // Function to poll game state periodically
        function pollGameState() {
            fetch(`/poll_game_state/${gameId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(data.error);
                        return;
                    }
                    updateGameState(data);
                });
        }

        // Function to check if it is the playerâ€™s turn
        function pollTurn() {
            fetch(`/poll_turn/${gameId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.is_turn) {
                        myTurn = true;
                        document.getElementById('turn-status').textContent = "Your turn!";
                        document.getElementById('input-area').style.display = "block";
                    } else {
                        myTurn = false;
                        document.getElementById('turn-status').textContent = "Waiting for opponent's move...";
                        document.getElementById('input-area').style.display = "none";
                    }
                });
        }

        // Function to submit a move
        function submitMove() {
            if (myTurn) {
                const prompt = document.getElementById('promptInput').value;
                fetch('/submit_move', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ game_id: gameId, prompt })
                })
                .then(response => response.json())
                .then(data => {
                    const moveLog = document.getElementById('move-log');
                    const newMove = document.createElement('p');
                    newMove.textContent = `You: ${data.prompt} - AI Response: ${data.response}`;
                    moveLog.appendChild(newMove);
                    document.getElementById('promptInput').value = '';
                });
            }
        }

        // Update the game state display
        function updateGameState(data) {
            const moveLog = document.getElementById('move-log');
            moveLog.innerHTML = '';
            data.turns.forEach(turn => {
                const move = document.createElement('p');
                move.textContent = `${turn.turnplayer}: ${turn.champion} - ${turn.how_champion_wins}`;
                moveLog.appendChild(move);
            });
        }

        // Poll game state and turn status every 5 seconds
        setInterval(pollGameState, 5000);
        setInterval(pollTurn, 5000);
    </script>
</body>
</html>
